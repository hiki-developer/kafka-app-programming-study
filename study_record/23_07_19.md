## 스터디 기록 (23.07.19)
---
### 질문  
건 : 프로듀서 인스턴스의 생성으로 Out of Memory Error가 우리 프로젝트에서 발생했던 걸까?  
- 프로듀서 인스턴스는 컴포넌트로써 하나의 빈으로써 생성되므로 OOME를 유발할 수 없을 것 같다.
- 추가로 kafka가 없던 초기 버전에서도 OOME는 발생했다. 내부 메세지 브로커의 사용이 가장 의심되는게 사실이다.


건 : 컨슈머를 구현해 사용해보니까 서버 종료시 shutdown hook를 통해 리소스 해제도 가능한 것 같다. 프로듀서와 컨슈머 서버를 분리해서 우리 프로젝트에 반영할 수 없을까? 특히 메시지 처리에 대해  
- 메시지 브로커는 세션 연결을 통해 채팅 메시지를 구독자들에게 전달하고 있다. 서버 분리를 통해 채팅 메시지 처리는 불가한 것 같다. 컨슈머 서버에서 해당 세션에 대한 정보를 알 수가 없다.

건 : `RebalanceListener`가 왜 컨슈머의 subscribe() 메서드의 인자로 사용되는 건가? 브로커에서 코디네이터에 해당하는 친구가 리밸런스를 하는데 브로커가 해당 리스너를 가져야 하지 않는가?  
- 브로커가 리밸런스를 하는 것이고 그거에 대한 리슨을 컨슈머 그룹에서 하는 것이 맞다.
- 따라서 `RebalanceListener`는 컨슈머의 subscribe() 메서드의 인자로 쓰여야 하고 리밸런스 동작시 그에 맞게 리스너가 동작하여 컨슈머에서 현재 오프셋을 저장하거나 새로운 컨슈머를 할당하는 작업을 하는 것이다.

  
---
### 어려웠던 개념
권재 : 라운드로빈으로 파티션을 할당하고 있는 줄 알았는데 아니었다.
- KafkaProducer 인스턴스가 send() 메서드를 호출하면 ProducerRecord는 파티셔너에서 토픽의 어느 파티션으로 전송될 것인지 정해진다. 파티셔너에 의해 구분된 레코드는 데이터를 전송하기 전에 어큐뮬레이터에 데이터를 버퍼로 쌓아놓고 발송한다. 버퍼로 쌓인 데이터는 배치로 묶어서 전송한다.
- 카프카 클라이언트 라이브러리 2.4.0 버전 부터는 `RoundRobinPartitioner`대신 `UniformStickyPartitioner`가 기본 파티셔너로 설정된다. `RoundRobinPartitioner`는 ProducerRecord가 들어오는 대로 파티션을 순회하며 전송하기 때문에 배치로 묶이는 빈도가 적다. 될 수 있으면 많은 데이터가 배치로 묶이면 좋기에 `UniformStickyPartitioner`는 이를 개선하여 어큐뮬레이터에서 데이터가 배치로 모두 묶일 때까지 기다렸다가 동일한 파티션에 전송한다.
